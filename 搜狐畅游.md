# 响应式布局 css布局是多套的还是一套的？用rem实现响应式布局还是多套的吗？

- 使用rem，动态的调整跟元素的字体大小，从而实现响应式布局。
- 媒体查询
- 弹性盒子布局，wrap，grow，shink实现自动缩放

# 在实习的项目中做过哪些性能优化的问题

- 动态导入文件
- 使用cdn
- 压缩文件
- 缓存
- 预加载，懒加载

## 字体动态导入是在什么时机进行动态导入，遇到过闪烁的问题吗？
在组件加载的时候动态导入
- 使用@font-face 动态导入字体文件，设置font-display属性
- 预加载一些字体 <link rel="preload"> 

## 怎么减小文件体积，哪些配置。webpack是通过哪些流程压缩的？
- 在生产模式下，使用webpack启动生产模式，会自动启动tree-shaking，压缩代码，去除无用的代码，
- 对图片进行压缩
- 在服务器端启用gzip，进行压缩。需要配置webpack生成.gz文件

# vite相对于webpack有哪些优势？为什么比较快？发生路由变化的时候是怎么实现热更新的
- 加载速度快，使用了esmodlue，浏览器对esmodule支持，直接使用esmodule加载代码，避免打包的过程
- 按需编译，只有在需要的时候才会编译，webpack在初始时要对所有的文件进行打包
- 热更新，在文件发生变化时能够快速编译并更新，无需刷新整个页面

怎么实现热更新的？
- vite会监听文件的是否被修改，修改后就会触发编译
- 对于被修改的模块，vite会生成一个更新的信息（json）格式。
- 通过websocket 向客户端发送一个更新的信息
- 客户端接收到信息后就根据信息找到更新的模块，调用hmr接口进行更新

# 浏览器缓存过程是怎样的？
- 当用户访问一个网页的时候，浏览器会检查是否有缓存，如果有且未过期的话则直接从缓存中读取数据并展现给用户。
- 如果没有或者是过期的话，会重新发送一个http请求，在请求头部携带一些缓存的相关信息，像 ```if-none-match``` 和 ```if-modified-since``` 等,这样以便询问浏览器是否发生更新
- 服务器接收到请求后根据请求头中的信息判断资源是否有更新。

## 强缓存与协商缓存
- 第一次访问页面的时候，浏览器向服务器发送请求获取资源。服务器响应请求，并在响应头中携带缓存的相关信息。
   cache-control 字段设置缓存策略，
   expires设置资源的过期时间，
   etag 服务器为资源生成的唯一标识，
   last-modified
- 当用户再次访问的时候哦，浏览器先检查本地缓存里面有没有未过期的缓存，
- 如果有过期的缓存，判断有没有etag
    有则向web服务器请求带有if-none-match的请求头（值一般是etag，进行对比，决定返回304还是200）。200是返回新的资源，304是返回缓存的资源。
    如果没有则看有没有last- modified 有的话则向web服务器请求带有if-modified-since的请求头。咨询资源是否有更新。
- 服务器接收到请求后根据请求头中的信息判断资源是否有更新。
- 如果没有更新，则返回304状态码，告诉浏览器可以直接使用缓存。

强缓存不会向服务器发送请求，协商缓存会向服务器发送请求。


# etag是怎么生成的？
在服务器端生成，并在响应头中返回给客户端。（主要有hash，元数据）

# promise的实现原理
跟踪当前的状态，维护一个回调队列，当状态改变时，调用回调队列中的回调函数。

# .all和.race的区别 .all中有一个失败fetch能捕捉到吗？
.all 会等待所有的promise都成功才会返回，有一个失败则返回失败的promise。
.allsettled 会等待所有的promise都成功或者失败才会返回。
.race会返回第一个完成的promise。
.any 有一个成功就可以

# axios 的 响应拦截和请求拦截

# node的中间件
- 中间件是一个函数，它接受一个请求对象和一个响应对象，并且可以对请求和响应进行修改。

# vue3的组合式api 的优点
## 提升组件的复用性
## 组合式api参考的什么方案

# 双向绑定的不同

# js的事件流




